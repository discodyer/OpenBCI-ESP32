#include <SPI.h>
#include "ADS1299.h"

extern SPIClass *hspi;

volatile bool ADS1299::channelDataAvailable = false;

/// @brief ADS1299 回调函数
/// @return
void IRAM_ATTR ADS1299::ADS_DRDY_Service()
{
    channelDataAvailable = true;
}

/// @brief Configure the test signals that can be inernally generated by the ADS1299
/// @param amplitudeCode
/// @param freqCode
void ADS1299::configureInternalTestSignal(byte amplitudeCode, byte freqCode)
{
    byte setting;
    ChipSelect targetSS;
    for (int i = 0; i < 2; i++)
    {
        if (i == 0)
        {
            targetSS = BOARD_ADS;
        }
        if (i == 1)
        {
            if (daisyPresent == false)
            {
                return;
            }
            targetSS = DAISY_ADS;
        }
        if (amplitudeCode == ADSTESTSIG_NOCHANGE)
            amplitudeCode = (RREG(CONFIG2, targetSS) & (0b00000100));
        if (freqCode == ADSTESTSIG_NOCHANGE)
            freqCode = (RREG(CONFIG2, targetSS) & (0b00000011));
        freqCode &= 0b00000011;                               // only the last two bits are used
        amplitudeCode &= 0b00000100;                          // only this bit is used
        byte setting = 0b11010000 | freqCode | amplitudeCode; // compose the code
        WREG(CONFIG2, setting, targetSS);
        delay(1);
#ifdef DEBUG
        Serial0.print("Wrote to CONFIG2: ");
        Serial0.print(setting, BIN);
#endif
    }
}

/// @brief SPI communication method
/// @param byte data
/// @return byte data
byte ADS1299::xfer(byte data)
{
    // 发送数据并接收返回的数据
    return hspi->transfer(data);
}

void ADS1299::changeInputType(byte inputCode)
{
    for (int i = 0; i < numChannels; i++)
    {
        channelSettings[i][INPUT_TYPE_SET] = inputCode;
    }

    // OLD CODE REVERT
    // channelSettingsArraySetForAll();

    writeChannelSettings();
}

void ADS1299::csLow(ChipSelect targetSS)
{
    // hspi->beginTransaction(SPISettings(ADS_SPI_SPEED, MSBFIRST, SPI_MODE1));
    // hspi->setFrequency(ADS_SPI_SPEED);
    switch (targetSS)
    {
    case BOARD_ADS:
        digitalWrite(PIN_ADS_CS1, LOW);
        break;
    case DAISY_ADS:
        digitalWrite(PIN_ADS_CS2, LOW);
        break;
    case BOTH_ADS:
        digitalWrite(PIN_ADS_CS1, LOW);
        digitalWrite(PIN_ADS_CS2, LOW);
        break;
    default:
        // 处理未知的枚举值
        break;
    }
}

/// @brief Used to set all channels on Board (and Daisy) to the default
///         channel settings if running must stop and start after...
/// @param
void ADS1299::streamSafeSetAllChannelsToDefault(void)
{
    boolean wasStreaming = streaming;

    // Stop streaming if you are currently streaming
    if (streaming)
    {
        streamStop();
    }

    setChannelsToDefault();

    // Restart stream if need be
    if (wasStreaming)
    {
        streamStart();
    }
}

void ADS1299::csHigh(ChipSelect targetSS)
{
    switch (targetSS)
    {
    case BOARD_ADS:
        digitalWrite(PIN_ADS_CS1, HIGH);
        break;
    case DAISY_ADS:
        digitalWrite(PIN_ADS_CS2, HIGH);
        break;
    case BOTH_ADS:
        digitalWrite(PIN_ADS_CS1, HIGH);
        digitalWrite(PIN_ADS_CS2, HIGH);
        break;
    default:
        // 处理未知的枚举值
        break;
    }
    // hspi->endTransaction();
}

void ADS1299::setChannelsToDefault(void)
{
    for (int i = 0; i < numChannels; i++)
    {
        for (int j = 0; j < 6; j++)
        {
            channelSettings[i][j] = defaultChannelSettings[j];
        }
        useInBias[i] = true; // keeping track of Bias Generation
        useSRB2[i] = true;   // keeping track of SRB2 inclusion
    }
    boardUseSRB1 = daisyUseSRB1 = false;

    writeChannelSettings(); // write settings to on-board ADS

    for (int i = 0; i < numChannels; i++)
    { // turn off the impedance measure signal
        leadOffSettings[i][PCHAN] = OFF;
        leadOffSettings[i][NCHAN] = OFF;
    }
    changeChannelLeadOffDetect(); // write settings to all ADS

    WREG(MISC1, 0x00, BOARD_ADS); // open SRB1 switch on-board
    if (daisyPresent)
    {
        WREG(MISC1, 0x00, DAISY_ADS);
    } // open SRB1 switch on-daisy
}

/// @brief reset all the registers to default settings
/// @param targetSS
void ADS1299::RESET(ChipSelect targetSS)
{
    // reset all the registers to default settings
    csLow(targetSS);
    xfer(_RESET);
    delayMicroseconds(12); // must wait 18 tCLK cycles to execute this command (Datasheet, pg. 35)
    csHigh(targetSS);
}

void ADS1299::removeDaisy(void)
{
    if (daisyPresent)
    {
        // Daisy removed
        SDATAC(DAISY_ADS);
        RESET(DAISY_ADS);
        STANDBY(DAISY_ADS);
        daisyPresent = false;
        if (!isRunning)
        {
            // printlnWifi("daisy removed");
        }
    }
    else
    {
        if (!isRunning)
        {
            // printlnWifi("no daisy to remove!");
        }
    }
}

/// @brief get out of read data continuous mode
/// @param targetSS
void ADS1299::SDATAC(ChipSelect targetSS)
{
    csLow(targetSS);
    xfer(_SDATAC);
    csHigh(targetSS);
    delayMicroseconds(10); // must wait at least 4 tCLK cycles after executing this command (Datasheet, pg. 37)
}

/// @brief Used to set lead off for a channel, if running must stop and start after...
/// @param channelNumber
/// @param powerDown
/// @param gain
/// @param inputType
/// @param bias
/// @param srb2
/// @param srb1
void ADS1299::streamSafeChannelSettingsForChannel(byte channelNumber, byte powerDown, byte gain, byte inputType, byte bias, byte srb2, byte srb1)
{
    boolean wasStreaming = streaming;

    // Stop streaming if you are currently streaming
    if (streaming)
    {
        streamStop();
    }

    writeChannelSettings(channelNumber);

    // channelSettingsSetForChannel(channelNumber, powerDown, gain, inputType, bias, srb2, srb1);

    // Restart stream if need be
    if (wasStreaming)
    {
        streamStart();
    }
}

/// @brief deactivate the given channel.
/// @param N
void ADS1299::deactivateChannel(byte N)
{
    byte setting, startChan, endChan;
    ADS1299::ChipSelect targetSS;

    if (N < 9)
    {
        targetSS = BOARD_ADS;
        startChan = 0;
        endChan = 8;
    }
    else
    {
        if (!daisyPresent)
        {
            return;
        }
        targetSS = DAISY_ADS;
        startChan = 8;
        endChan = 16;
    }
    SDATAC(targetSS);
    delay(1);                                     // exit Read Data Continuous mode to communicate with ADS
    N = constrain(N - 1, startChan, endChan - 1); // subtracts 1 so that we're counting from 0, not 1

    setting = RREG(CH1SET + (N - startChan), targetSS);
    delay(1);             // get the current channel settings
    bitSet(setting, 7);   // set bit7 to shut down channel
    bitClear(setting, 3); // clear bit3 to disclude from SRB2 if used
    WREG(CH1SET + (N - startChan), setting, targetSS);
    delay(1); // write the new value to disable the channel

    // remove the channel from the bias generation...
    setting = RREG(BIAS_SENSP, targetSS);
    delay(1);                         // get the current bias settings
    bitClear(setting, N - startChan); // clear this channel's bit to remove from bias generation
    WREG(BIAS_SENSP, setting, targetSS);
    delay(1); // send the modified byte back to the ADS

    setting = RREG(BIAS_SENSN, targetSS);
    delay(1);                         // get the current bias settings
    bitClear(setting, N - startChan); // clear this channel's bit to remove from bias generation
    WREG(BIAS_SENSN, setting, targetSS);
    delay(1); // send the modified byte back to the ADS

    leadOffSettings[N][0] = leadOffSettings[N][1] = NO;
    changeChannelLeadOffDetect(N + 1);
}

/// @brief Used to set lead off for a channel, if running must stop and start after...
/// @param channelNumber [byte] - The channel you want to change
/// @param pInput [byte] - Apply signal to P input, either ON (1) or OFF (0)
/// @param nInput [byte] - Apply signal to N input, either ON (1) or OFF (0)
void ADS1299::streamSafeLeadOffSetForChannel(byte channelNumber, byte pInput, byte nInput)
{
    boolean wasStreaming = streaming;

    // Stop streaming if you are currently streaming
    if (streaming)
    {
        streamStop();
    }

    changeChannelLeadOffDetect(channelNumber);

    // leadOffSetForChannel(channelNumber, pInput, nInput);

    // Restart stream if need be
    if (wasStreaming)
    {
        streamStart();
    }
}

/// @brief read one ADS register
/// @param _address
/// @param targetSS
/// @return
byte ADS1299::RREG(byte _address, ChipSelect targetSS)
{                                   //  reads ONE register at _address
    byte opcode1 = _address + 0x20; //  RREG expects 001rrrrr where rrrrr = _address
    csLow(targetSS);                //  open SPI
    xfer(opcode1);                  //  opcode1
    xfer(0x00);                     //  opcode2
    regData[_address] = xfer(0x00); //  update mirror location with returned byte
    csHigh(targetSS);               //  close SPI
    return regData[_address];       // return requested register value
}

/// @brief Used to set the sample rate
/// @param sr {SAMPLE_RATE} - The sample rate to set to.
void ADS1299::streamSafeSetSampleRate(SAMPLE_RATE sr)
{
    boolean wasStreaming = streaming;

    // Stop streaming if you are currently streaming
    if (streaming)
    {
        streamStop();
    }

    setSampleRate(sr);

    // Restart stream if need be
    if (wasStreaming)
    {
        streamStart();
    }
}

/// @brief write one ADS register
/// @param
/// @param
/// @param
void ADS1299::WREG(byte _address, byte _value, ChipSelect target_SS)
{                                   //  Write ONE register at _address
    byte opcode1 = _address + 0x40; //  WREG expects 010rrrrr where rrrrr = _address
    csLow(target_SS);               //  open SPI
    xfer(opcode1);                  //  Send WREG command & address
    xfer(0x00);                     //  Send number of registers to read -1
    xfer(_value);                   //  Write the value to the register
    csHigh(target_SS);              //  close SPI
    regData[_address] = _value;     //  update the mirror array
}

/// @brief Used to set the channelSettings array to default settings
/// @param setting [byte] - The byte you need a setting for....
/// @return [char] - Retuns the proper ascii char for the input setting, defaults to '0'
char ADS1299::getDefaultChannelSettingForSettingAscii(byte setting)
{
    switch (setting)
    {
    case GAIN_SET: // Special case where GAIN_SET needs to be shifted first
        return (ADS_GAIN24 >> 4) + '0';
    default: // All other settings are just adding the ascii value for '0'
        return getDefaultChannelSettingForSetting(setting) + '0';
    }
}

/// @brief stop data conversion
/// @param targetSS
void ADS1299::STOP(ChipSelect targetSS)
{
    csLow(targetSS);
    xfer(_STOP); // KEEP ON-BOARD AND ON-DAISY IN SYNC
    csHigh(targetSS);
}

/// @brief Used to set the channelSettings array to default settings
/// @param setting [byte] - The byte you need a setting for....
/// @return Retuns the proper byte for the input setting, defualts to 0
byte ADS1299::getDefaultChannelSettingForSetting(byte setting)
{
    switch (setting)
    {
    case POWER_DOWN:
        return NO;
    case GAIN_SET:
        return ADS_GAIN24;
    case INPUT_TYPE_SET:
        return ADSINPUT_NORMAL;
    case BIAS_SET:
        return YES;
    case SRB2_SET:
        return YES;
    case SRB1_SET:
    default:
        return NO;
    }
}

// void ADS1299::printfWifi(const char *format, ...)
// {
//     // Use a buffer to store the formatted string
//     char buffer[256];

//     // Use va_list to handle variable arguments
//     va_list args;
//     va_start(args, format);
//     vsnprintf(buffer, sizeof(buffer), format, args);
//     va_end(args);

//     // Process the formatted string using ProcessPacketResponse
//     String message(buffer);
//     board.ProcessPacketResponse(message);
// }

// void ADS1299::printlnWifi(const char *msg)
// {
//     String message(msg);
//     message + "\r\n";
//     board.ProcessPacketResponse(message);
// }

// void ADS1299::printWifi(const char *msg)
// {
//     String message(msg);
//     board.ProcessPacketResponse(message);
// }

/// @brief read data continuous
/// @param targetSS
void ADS1299::RDATAC(ChipSelect targetSS)
{
    csLow(targetSS);
    xfer(_RDATAC); // read data continuous
    csHigh(targetSS);
    delayMicroseconds(3);
}

/// @brief start data conversion
/// @param targetSS
void ADS1299::START(ChipSelect targetSS)
{
    csLow(targetSS);
    xfer(_START); // KEEP ON-BOARD AND ON-DAISY IN SYNC
    csHigh(targetSS);
}

/// @brief only allowed to send WAKEUP after sending STANDBY
/// @param targetSS
void ADS1299::STANDBY(ChipSelect targetSS)
{
    csLow(targetSS);
    xfer(_STANDBY);
    csHigh(targetSS);
}

ADS1299::ADS1299()
    : lastSampleTime(0), sampleCounter(0), curSampleRate(SAMPLE_RATE_250),
      isRunning(false)
{
    // ();
    // softReset();
}

/// @brief 初始化 ADS1299
void ADS1299::initialize()
{
    // 配置 引脚
    pinMode(PIN_ADS_CS1, OUTPUT); // BOARD_ADS ChipSelect Pin
    pinMode(PIN_ADS_CS2, OUTPUT); // DAISY_ADS ChipSelect Pin
    csHigh(BOTH_ADS);

    this->startHSPI();
    initialize_ads();
}

void ADS1299::attachDaisy(void)
{
    WREG(CONFIG1, (ADS1299_CONFIG1_DAISY | curSampleRate), BOARD_ADS); // tell on-board ADS to output the clk, set the data rate to 250SPS
    delay(40);
    resetADS(DAISY_ADS); // software reset daisy module if present
    delay(10);
    daisyPresent = smellDaisy();
    if (!daisyPresent)
    {
        WREG(CONFIG1, (ADS1299_CONFIG1_DAISY_NOT | curSampleRate), BOARD_ADS); // turn off clk output if no daisy present
        numChannels = 8;                                                       // expect up to 8 ADS channels
        // if (!isRunning)
        // {
        //     printlnWifi("no daisy to attach!");
        // }
    }
    else
    {
        numChannels = 16; // expect up to 16 ADS channels
        // if (!isRunning)
        // {
        //     printlnWifi("daisy attached");
        // }
    }
}

void ADS1299::setSampleRate(uint8_t newSampleRateCode)
{
    curSampleRate = (SAMPLE_RATE)newSampleRateCode;
    initialize_ads();
}

void ADS1299::initialize_ads()
{
    // recommended power up sequence requiers >Tpor (~32mS)
    delay(50);
    pinMode(PIN_ADS_RESET, OUTPUT);
    digitalWrite(PIN_ADS_RESET, LOW);  // reset pin connected to both ADS ICs
    delayMicroseconds(4);              // toggle reset pin
    digitalWrite(PIN_ADS_RESET, HIGH); // this will reset the Daisy if it is present
    delayMicroseconds(20);             // recommended to wait 18 Tclk before using device (~8uS);
    // initalize the  data ready chip select and reset pins:
    pinMode(PIN_ADS_DRDY, INPUT); // we get DRDY asertion from the on-board ADS
    delay(40);
    resetADS(BOARD_ADS); // reset the on-board ADS registers, and stop DataContinuousMode
    delay(10);
    WREG(CONFIG1, (ADS1299_CONFIG1_DAISY | curSampleRate), BOARD_ADS); // tell on-board ADS to output its clk, set the data rate to 250SPS
    delay(40);
    resetADS(DAISY_ADS); // software reset daisy module if present
    delay(10);
    daisyPresent = smellDaisy(); // check to see if daisy module is present
    if (!daisyPresent)
    {
        WREG(CONFIG1, (ADS1299_CONFIG1_DAISY_NOT | curSampleRate), BOARD_ADS); // turn off clk output if no daisy present
        numChannels = 8;                                                       // expect up to 8 ADS channels
    }
    else
    {
        numChannels = 16;                                                      // expect up to 16 ADS channels
        WREG(CONFIG1, (ADS1299_CONFIG1_DAISY_NOT | curSampleRate), DAISY_ADS); // tell on-board ADS to output its clk, set the data rate to 250SPS
        delay(40);
    }

    // DEFAULT CHANNEL SETTINGS FOR ADS
    defaultChannelSettings[POWER_DOWN] = NO;                  // on = NO, off = YES
    defaultChannelSettings[GAIN_SET] = ADS_GAIN24;            // Gain setting
    defaultChannelSettings[INPUT_TYPE_SET] = ADSINPUT_NORMAL; // input muxer setting
    defaultChannelSettings[BIAS_SET] = YES;                   // add this channel to bias generation
    defaultChannelSettings[SRB2_SET] = YES;                   // connect this P side to SRB2
    defaultChannelSettings[SRB1_SET] = NO;                    // don't use SRB1

    for (int i = 0; i < numChannels; i++)
    {
        for (int j = 0; j < 6; j++)
        {
            channelSettings[i][j] = defaultChannelSettings[j]; // assign default settings
        }
        useInBias[i] = true; // keeping track of Bias Generation
        useSRB2[i] = true;   // keeping track of SRB2 inclusion
    }
    boardUseSRB1 = daisyUseSRB1 = false;

    writeChannelSettings(); // write settings to the on-board and on-daisy ADS if present

    WREG(CONFIG3, 0b11101100, BOTH_ADS);
    delay(1); // enable internal reference drive and etc.
    for (int i = 0; i < numChannels; i++)
    { // turn off the impedance measure signal
        leadOffSettings[i][PCHAN] = OFF;
        leadOffSettings[i][NCHAN] = OFF;
    }
    verbosity = false; // when verbosity is true, there will be Serial feedback
    firstDataPacket = true;

    streaming = false;
}

/// @brief reset all the ADS1299's settings
/// @param targetSS
void ADS1299::resetADS(ChipSelect targetSS)
{
    int startChan, stopChan;
    if (targetSS == BOARD_ADS)
    {
        startChan = 1;
        stopChan = 8;
    }
    if (targetSS == DAISY_ADS)
    {
        startChan = 9;
        stopChan = 16;
    }
    RESET(targetSS);  // send RESET command to default all registers
    SDATAC(targetSS); // exit Read Data Continuous mode to communicate with ADS
    delay(100);
    // turn off all channels
    for (int chan = startChan; chan <= stopChan; chan++)
    {
        deactivateChannel(chan);
    }
}

/// @brief check if daisy present
/// @param
/// @return
boolean ADS1299::smellDaisy(void)
{
    boolean isDaisy = false;
    byte setting = RREG(ID_REG, DAISY_ADS); // try to read the daisy product ID
    if (setting == ADS_ID)
    {
        isDaisy = true;
    } // should read as 0x3E
    return isDaisy;
}

void ADS1299::writeChannelSettings(void)
{
    boolean use_SRB1 = false;
    byte setting, startChan, endChan;
    ChipSelect targetSS;

    for (int b = 0; b < 2; b++)
    {
        if (b == 0)
        {
            targetSS = BOARD_ADS;
            startChan = 0;
            endChan = 8;
        }
        if (b == 1)
        {
            if (!daisyPresent)
            {
                return;
            }
            targetSS = DAISY_ADS;
            startChan = 8;
            endChan = 16;
        }

        SDATAC(targetSS);
        delay(1); // exit Read Data Continuous mode to communicate with ADS

        for (byte i = startChan; i < endChan; i++)
        { // write 8 channel settings
            setting = 0x00;
            if (channelSettings[i][POWER_DOWN] == YES)
            {
                setting |= 0x80;
            }
            setting |= channelSettings[i][GAIN_SET];       // gain
            setting |= channelSettings[i][INPUT_TYPE_SET]; // input code
            if (channelSettings[i][SRB2_SET] == YES)
            {
                setting |= 0x08;   // close this SRB2 switch
                useSRB2[i] = true; // remember SRB2 state for this channel
            }
            else
            {
                useSRB2[i] = false; // rememver SRB2 state for this channel
            }
            WREG(CH1SET + (i - startChan), setting, targetSS); // write this channel's register settings

            // add or remove this channel from inclusion in BIAS generation
            setting = RREG(BIAS_SENSP, targetSS); // get the current P bias settings
            if (channelSettings[i][BIAS_SET] == YES)
            {
                bitSet(setting, i - startChan);
                useInBias[i] = true; // add this channel to the bias generation
            }
            else
            {
                bitClear(setting, i - startChan);
                useInBias[i] = false; // remove this channel from bias generation
            }
            WREG(BIAS_SENSP, setting, targetSS);
            delay(1); // send the modified byte back to the ADS

            setting = RREG(BIAS_SENSN, targetSS); // get the current N bias settings
            if (channelSettings[i][BIAS_SET] == YES)
            {
                bitSet(setting, i - startChan); // set this channel's bit to add it to the bias generation
            }
            else
            {
                bitClear(setting, i - startChan); // clear this channel's bit to remove from bias generation
            }
            WREG(BIAS_SENSN, setting, targetSS);
            delay(1); // send the modified byte back to the ADS

            if (channelSettings[i][SRB1_SET] == YES)
            {
                use_SRB1 = true; // if any of the channel setting closes SRB1, it is closed for all
            }
        } // end of CHnSET and BIAS settings
    }     // end of board select loop
    if (use_SRB1)
    {
        for (int i = startChan; i < endChan; i++)
        {
            channelSettings[i][SRB1_SET] = YES;
        }
        WREG(MISC1, 0x20, targetSS); // close SRB1 swtich
        if (targetSS == BOARD_ADS)
        {
            boardUseSRB1 = true;
        }
        if (targetSS == DAISY_ADS)
        {
            daisyUseSRB1 = true;
        }
    }
    else
    {
        for (int i = startChan; i < endChan; i++)
        {
            channelSettings[i][SRB1_SET] = NO;
        }
        WREG(MISC1, 0x00, targetSS); // open SRB1 switch
        if (targetSS == BOARD_ADS)
        {
            boardUseSRB1 = false;
        }
        if (targetSS == DAISY_ADS)
        {
            daisyUseSRB1 = false;
        }
    }
}

void ADS1299::writeChannelSettings(byte N)
{
    byte setting, startChan, endChan;
    ChipSelect targetSS;

    if (N < 9)
    { // channels 1-8 on board
        targetSS = BOARD_ADS;
        startChan = 0;
        endChan = 8;
    }
    else
    { // channels 9-16 on daisy module
        if (!daisyPresent)
        {
            return;
        }
        targetSS = DAISY_ADS;
        startChan = 8;
        endChan = 16;
    }
    // function accepts channel 1-16, must be 0 indexed to work with array
    N = constrain(N - 1, startChan, endChan - 1); // subtracts 1 so that we're counting from 0, not 1
    // first, disable any data collection
    SDATAC(targetSS);
    delay(1); // exit Read Data Continuous mode to communicate with ADS

    setting = 0x00;
    if (channelSettings[N][POWER_DOWN] == YES)
        setting |= 0x80;
    setting |= channelSettings[N][GAIN_SET];       // gain
    setting |= channelSettings[N][INPUT_TYPE_SET]; // input code
    if (channelSettings[N][SRB2_SET] == YES)
    {
        setting |= 0x08;   // close this SRB2 switch
        useSRB2[N] = true; // keep track of SRB2 usage
    }
    else
    {
        useSRB2[N] = false;
    }
    WREG(CH1SET + (N - startChan), setting, targetSS); // write this channel's register settings

    // add or remove from inclusion in BIAS generation
    setting = RREG(BIAS_SENSP, targetSS); // get the current P bias settings
    if (channelSettings[N][BIAS_SET] == YES)
    {
        useInBias[N] = true;
        bitSet(setting, N - startChan); // set this channel's bit to add it to the bias generation
    }
    else
    {
        useInBias[N] = false;
        bitClear(setting, N - startChan); // clear this channel's bit to remove from bias generation
    }
    WREG(BIAS_SENSP, setting, targetSS);
    delay(1);                             // send the modified byte back to the ADS
    setting = RREG(BIAS_SENSN, targetSS); // get the current N bias settings
    if (channelSettings[N][BIAS_SET] == YES)
    {
        bitSet(setting, N - startChan); // set this channel's bit to add it to the bias generation
    }
    else
    {
        bitClear(setting, N - startChan); // clear this channel's bit to remove from bias generation
    }
    WREG(BIAS_SENSN, setting, targetSS);
    delay(1); // send the modified byte back to the ADS

    // if SRB1 is closed or open for one channel, it will be the same for all channels
    if (channelSettings[N][SRB1_SET] == YES)
    {
        for (int i = startChan; i < endChan; i++)
        {
            channelSettings[i][SRB1_SET] = YES;
        }
        if (targetSS == BOARD_ADS)
            boardUseSRB1 = true;
        if (targetSS == DAISY_ADS)
            daisyUseSRB1 = true;
        setting = 0x20; // close SRB1 swtich
    }
    if (channelSettings[N][SRB1_SET] == NO)
    {
        for (int i = startChan; i < endChan; i++)
        {
            channelSettings[i][SRB1_SET] = NO;
        }
        if (targetSS == BOARD_ADS)
            boardUseSRB1 = false;
        if (targetSS == DAISY_ADS)
            daisyUseSRB1 = false;
        setting = 0x00; // open SRB1 switch
    }
    WREG(MISC1, setting, targetSS);
}

/// @brief change the lead off detect settings for all channels
void ADS1299::changeChannelLeadOffDetect()
{
    byte setting, startChan, endChan;
    ChipSelect targetSS;

    for (int b = 0; b < 2; b++)
    {
        if (b == 0)
        {
            targetSS = BOARD_ADS;
            startChan = 0;
            endChan = 8;
        }
        if (b == 1)
        {
            if (!daisyPresent)
            {
                return;
            }
            targetSS = DAISY_ADS;
            startChan = 8;
            endChan = 16;
        }

        SDATAC(targetSS);
        delay(1); // exit Read Data Continuous mode to communicate with ADS
        byte P_setting = RREG(LOFF_SENSP, targetSS);
        byte N_setting = RREG(LOFF_SENSN, targetSS);

        for (int i = startChan; i < endChan; i++)
        {
            if (leadOffSettings[i][PCHAN] == ON)
            {
                bitSet(P_setting, i - startChan);
            }
            else
            {
                bitClear(P_setting, i - startChan);
            }
            if (leadOffSettings[i][NCHAN] == ON)
            {
                bitSet(N_setting, i - startChan);
            }
            else
            {
                bitClear(N_setting, i - startChan);
            }
            WREG(LOFF_SENSP, P_setting, targetSS);
            WREG(LOFF_SENSN, N_setting, targetSS);
        }
    }
}

/// @brief change the lead off detect settings for specified channel
/// @param N
void ADS1299::changeChannelLeadOffDetect(byte N)
{
    byte setting, startChan, endChan;
    ChipSelect targetSS;

    if (N < 9)
    {
        targetSS = BOARD_ADS;
        startChan = 0;
        endChan = 8;
    }
    else
    {
        if (!daisyPresent)
        {
            return;
        }
        targetSS = DAISY_ADS;
        startChan = 8;
        endChan = 16;
    }

    N = constrain(N - 1, startChan, endChan - 1);
    SDATAC(targetSS);
    delay(1); // exit Read Data Continuous mode to communicate with ADS
    byte P_setting = RREG(LOFF_SENSP, targetSS);
    byte N_setting = RREG(LOFF_SENSN, targetSS);

    if (leadOffSettings[N][PCHAN] == ON)
    {
        bitSet(P_setting, N - startChan);
    }
    else
    {
        bitClear(P_setting, N - startChan);
    }
    if (leadOffSettings[N][NCHAN] == ON)
    {
        bitSet(N_setting, N - startChan);
    }
    else
    {
        bitClear(N_setting, N - startChan);
    }
    WREG(LOFF_SENSP, P_setting, targetSS);
    WREG(LOFF_SENSN, N_setting, targetSS);
}

/// @brief This is a function that can be called multiple times, this is
//         what we refer to as a `soft reset`. You will hear/see this
//         many times.
/// @param
void ADS1299::softReset(void)
{
    this->initialize();
    delay(500);
    configureLeadOffDetection(LOFF_MAG_6NA, LOFF_FREQ_31p2HZ);
    Serial0.println("OpenBCI V3 8-16 channel");
    Serial0.printf("On Board ADS1299 Device ID: 0x%X\n", ADS_getDeviceID(BOARD_ADS));
    if (daisyPresent)
    {
        Serial0.printf("On Daisy ADS1299 Device ID: 0x%X\n", ADS_getDeviceID(DAISY_ADS));
    }
    delay(5);
}

void ADS1299::configureLeadOffDetection(byte amplitudeCode, byte freqCode)
{
    amplitudeCode &= 0b00001100; // only these two bits should be used
    freqCode &= 0b00000011;      // only these two bits should be used

    byte setting;
    ChipSelect targetSS;
    for (int i = 0; i < 2; i++)
    {
        if (i == 0)
        {
            targetSS = BOARD_ADS;
        }
        if (i == 1)
        {
            if (!daisyPresent)
            {
                return;
            }
            targetSS = DAISY_ADS;
        }
        setting = RREG(LOFF, targetSS); // get the current bias settings
        // reconfigure the byte to get what we want
        setting &= 0b11110000;    // clear out the last four bits
        setting |= amplitudeCode; // set the amplitude
        setting |= freqCode;      // set the frequency
        // send the config byte back to the hardware
        WREG(LOFF, setting, targetSS);
        delay(1); // send the modified byte back to the ADS
    }
}

byte ADS1299::ADS_getDeviceID(ChipSelect targetSS)
{
    // simple hello world com check
    byte data = RREG(ID_REG, targetSS);
    return data;
}

void ADS1299::boardBeginADSInterrupt(void)
{
    // 配置 DRDY 外部中断
    pinMode(PIN_ADS_DRDY, INPUT); // ADS data ready pin
    attachInterrupt(PIN_ADS_DRDY, ADS_DRDY_Service, FALLING);
}

/// @brief CALLED WHEN DRDY PIN IS ASSERTED. NEW ADS DATA AVAILABLE!
/// @param
void ADS1299::updateChannelData(void)
{
    // this needs to be reset, or else it will constantly flag us
    channelDataAvailable = false;

    lastSampleTime = millis();

    boolean downsample = true;

    updateBoardData(downsample);
    if (daisyPresent)
    {
        updateDaisyData(downsample);
    }

    // switch (curBoardMode)
    // {
    // case BOARD_MODE_ANALOG:
    //     auxData[0] = analogRead(A5);
    //     auxData[1] = analogRead(A6);
    //     if (!wifi.present)
    //     {
    //         auxData[2] = analogRead(A7);
    //     }
    //     break;
    // case BOARD_MODE_DIGITAL:
    //     auxData[0] = digitalRead(11) << 8 | digitalRead(12);
    //     auxData[1] = (wifi.present ? 0 : digitalRead(13) << 8) | digitalRead(17);
    //     auxData[2] = wifi.present ? 0 : digitalRead(18);
    //     break;
    // case BOARD_MODE_MARKER:
    //     if (newMarkerReceived)
    //     {
    //         auxData[0] = (short)markerValue;
    //         newMarkerReceived = false;
    //     }
    //     break;
    // case BOARD_MODE_BLE:
    // case BOARD_MODE_DEBUG:
    // case BOARD_MODE_DEFAULT:
    //     break;
    // }
}

void ADS1299::updateBoardData(void)
{
    updateBoardData(true);
}

void ADS1299::updateBoardData(boolean downsample)
{
    byte inByte;
    int byteCounter = 0;

    if ((daisyPresent) && !firstDataPacket && downsample)
    {
        for (int i = 0; i < OPENBCI_ADS_CHANS_PER_BOARD; i++)
        {                                                        // shift and average the byte arrays
            lastBoardChannelDataInt[i] = boardChannelDataInt[i]; // remember the last samples
        }
    }

    csLow(BOARD_ADS); //  open SPI
    for (int i = 0; i < 3; i++)
    {
        inByte = xfer(0x00); //  read status register (1100 + LOFF_STATP + LOFF_STATN + GPIO[7:4])
        boardStat = (boardStat << 8) | inByte;
    }
    for (int i = 0; i < OPENBCI_ADS_CHANS_PER_BOARD; i++)
    {
        for (int j = 0; j < OPENBCI_ADS_BYTES_PER_CHAN; j++)
        { //  read 24 bits of channel data in 8 3 byte chunks
            inByte = xfer(0x00);
            boardChannelDataRaw[byteCounter] = inByte; // raw data goes here
            byteCounter++;
            boardChannelDataInt[i] = (boardChannelDataInt[i] << 8) | inByte; // int data goes here
        }
    }
    csHigh(BOARD_ADS); // close SPI

    // need to convert 24bit to 32bit if using the filter
    for (int i = 0; i < OPENBCI_ADS_CHANS_PER_BOARD; i++)
    { // convert 3 byte 2's compliment to 4 byte 2's compliment
        if (bitRead(boardChannelDataInt[i], 23) == 1)
        {
            boardChannelDataInt[i] |= 0xFF000000;
        }
        else
        {
            boardChannelDataInt[i] &= 0x00FFFFFF;
        }
    }
    if ((daisyPresent) && !firstDataPacket && downsample)
    {
        byteCounter = 0;
        for (int i = 0; i < OPENBCI_ADS_CHANS_PER_BOARD; i++)
        { // take the average of this and the last sample
            meanBoardChannelDataInt[i] = (lastBoardChannelDataInt[i] + boardChannelDataInt[i]) / 2;
        }
        for (int i = 0; i < OPENBCI_ADS_CHANS_PER_BOARD; i++)
        { // place the average values in the meanRaw array
            for (int b = 2; b >= 0; b--)
            {
                meanBoardDataRaw[byteCounter] = (meanBoardChannelDataInt[i] >> (b * 8)) & 0xFF;
                byteCounter++;
            }
        }
    }

    if (firstDataPacket == true)
    {
        firstDataPacket = false;
    }
}

/// @brief Read from the Daisy's ADS1299 chip and fill the core arrays with
//         new data. Defaults to downsampling if the daisy is present.
/// @param
void ADS1299::updateDaisyData(void)
{
    updateDaisyData(true);
}

/// @brief Read from the Daisy's ADS1299 chip and fill the core arrays with
//         new data.
/// @param  downsample {boolean} - Averages the last sample with the current to cut the sample rate in half.
void ADS1299::updateDaisyData(boolean downsample)
{
    byte inByte;
    int byteCounter = 0;

    if (daisyPresent && !firstDataPacket && downsample)
    {
        for (int i = 0; i < OPENBCI_ADS_CHANS_PER_BOARD; i++)
        {                                                        // shift and average the byte arrays
            lastDaisyChannelDataInt[i] = daisyChannelDataInt[i]; // remember the last samples
        }
    }

    // Open SPI
    csLow(DAISY_ADS);
    // Read status register (1100 + LOFF_STATP + LOFF_STATN + GPIO[7:4])
    // TODO: Do we really need to read this status register ever time?
    for (int i = 0; i < 3; i++)
    {
        inByte = xfer(0x00);
        daisyStat = (daisyStat << 8) | inByte;
    }

    // Read 24 bits of channel data in 8 3 byte chunks
    for (int i = 0; i < OPENBCI_ADS_CHANS_PER_BOARD; i++)
    {
        for (int j = 0; j < OPENBCI_ADS_BYTES_PER_CHAN; j++)
        {
            inByte = xfer(0x00);
            daisyChannelDataRaw[byteCounter] = inByte; // raw data goes here
            byteCounter++;
            daisyChannelDataInt[i] = (daisyChannelDataInt[i] << 8) | inByte; // int data goes here
        }
    }

    // Close SPI
    csHigh(DAISY_ADS);

    // Convert 24bit to 32bit
    for (int i = 0; i < OPENBCI_ADS_CHANS_PER_BOARD; i++)
    {
        // Convert 3 byte 2's compliment to 4 byte 2's compliment
        if (bitRead(daisyChannelDataInt[i], 23) == 1)
        {
            daisyChannelDataInt[i] |= 0xFF000000;
        }
        else
        {
            daisyChannelDataInt[i] &= 0x00FFFFFF;
        }
    }

    if (daisyPresent && !firstDataPacket && downsample)
    {
        byteCounter = 0;
        // Average this sample with the last sample
        for (int i = 0; i < OPENBCI_ADS_CHANS_PER_BOARD; i++)
        {
            meanDaisyChannelDataInt[i] = (lastDaisyChannelDataInt[i] + daisyChannelDataInt[i]) / 2;
        }
        // Place the average values in the meanRaw array
        for (int i = 0; i < OPENBCI_ADS_CHANS_PER_BOARD; i++)
        {
            for (int b = 2; b >= 0; b--)
            {
                meanDaisyDataRaw[byteCounter] = (meanDaisyChannelDataInt[i] >> (b * 8)) & 0xFF;
                byteCounter++;
            }
        }
    }

    if (firstDataPacket == true)
    {
        firstDataPacket = false;
    }
}

/// @brief Called from the .ino file as the main sender. Driven by board mode,
//         sample number, and ultimately the current packer type.
/// @param
void ADS1299::sendChannelData(void)
{
    // sendChannelDataWifi(); // todo!
    sendChannelDataSerial();
    // sampleCounter++;
}

void ADS1299::sendChannelDataSerial()
{
    Serial0.println("Channel data sent"); // todo!
}

void ADS1299::start()
{
    boardBeginADSInterrupt();
    softReset();
}

void ADS1299::startHSPI(void)
{
    hspi->begin(PIN_SPI_SCLK, PIN_SPI_MISO, PIN_SPI_MOSI, -1);
    hspi->setFrequency(ADS_SPI_SPEED); // use 4MHz for ADS
    hspi->setDataMode(SPI_MODE3);
}

ADS1299::~ADS1299()
{
}

/// @brief Used to activate a channel, if running must stop and start after...
/// @param channelNumber int the channel you want to change
void ADS1299::streamSafeChannelActivate(byte channelNumber)
{
    boolean wasStreaming = streaming;

    // Stop streaming if you are currently streaming
    if (streaming)
    {
        streamStop();
    }

    // Activate the channel
    activateChannel(channelNumber);

    // Restart stream if need be
    if (wasStreaming)
    {
        streamStart();
    }
}

void ADS1299::activateChannel(byte N)
{
    byte setting, startChan, endChan;
    ChipSelect targetSS;
    if (N < 9)
    {
        targetSS = BOARD_ADS;
        startChan = 0;
        endChan = 8;
    }
    else
    {
        if (!daisyPresent)
        {
            return;
        }
        targetSS = DAISY_ADS;
        startChan = 8;
        endChan = 16;
    }

    N = constrain(N - 1, startChan, endChan - 1); // 0-7 or 8-15

    SDATAC(targetSS); // exit Read Data Continuous mode to communicate with ADS
    setting = 0x00;
    //  channelSettings[N][POWER_DOWN] = NO; // keep track of channel on/off in this array  REMOVE?
    setting |= channelSettings[N][GAIN_SET];       // gain
    setting |= channelSettings[N][INPUT_TYPE_SET]; // input code
    if (useSRB2[N] == true)
    {
        channelSettings[N][SRB2_SET] = YES;
    }
    else
    {
        channelSettings[N][SRB2_SET] = NO;
    }
    if (channelSettings[N][SRB2_SET] == YES)
    {
        bitSet(setting, 3);
    } // close this SRB2 switch
    WREG(CH1SET + (N - startChan), setting, targetSS);
    // add or remove from inclusion in BIAS generation
    if (useInBias[N])
    {
        channelSettings[N][BIAS_SET] = YES;
    }
    else
    {
        channelSettings[N][BIAS_SET] = NO;
    }
    setting = RREG(BIAS_SENSP, targetSS); // get the current P bias settings
    if (channelSettings[N][BIAS_SET] == YES)
    {
        bitSet(setting, N - startChan); // set this channel's bit to add it to the bias generation
        useInBias[N] = true;
    }
    else
    {
        bitClear(setting, N - startChan); // clear this channel's bit to remove from bias generation
        useInBias[N] = false;
    }
    WREG(BIAS_SENSP, setting, targetSS);
    delay(1);                             // send the modified byte back to the ADS
    setting = RREG(BIAS_SENSN, targetSS); // get the current N bias settings
    if (channelSettings[N][BIAS_SET] == YES)
    {
        bitSet(setting, N - startChan); // set this channel's bit to add it to the bias generation
    }
    else
    {
        bitClear(setting, N - startChan); // clear this channel's bit to remove from bias generation
    }
    WREG(BIAS_SENSN, setting, targetSS);
    delay(1); // send the modified byte back to the ADS

    setting = 0x00;
    if (targetSS == BOARD_ADS && boardUseSRB1 == true)
        setting = 0x20;
    if (targetSS == DAISY_ADS && daisyUseSRB1 == true)
        setting = 0x20;
    WREG(MISC1, setting, targetSS); // close all SRB1 swtiches
}

void ADS1299::activateAllChannelsToTestCondition(byte testInputCode, byte amplitudeCode, byte freqCode)
{
    boolean wasStreaming = streaming;

    // Stop streaming if you are currently streaming
    if (streaming)
    {
        streamStop();
    }

    // set the test signal to the desired state
    configureInternalTestSignal(amplitudeCode, freqCode);
    // change input type settings for all channels
    changeInputType(testInputCode);

    // Restart stream if need be
    if (wasStreaming)
    {
        streamStart();
    }
    else
    {
        // printlnWifi("Configured internal test signal.");
    }
}

/// @brief Used to deactivate a channel, if running must stop and start after...
/// @param channelNumber {int} - the channel you want to change
void ADS1299::streamSafeChannelDeactivate(byte channelNumber)
{
    boolean wasStreaming = streaming;

    // Stop streaming if you are currently streaming
    if (streaming)
    {
        streamStop();
    }

    // deactivate the channel
    deactivateChannel(channelNumber);

    // Restart stream if need be
    if (wasStreaming)
    {
        streamStart();
    }
}

/// @brief Call this to stop streaming from the ADS1299
void ADS1299::streamStop()
{
    streaming = false;
    stopADS();
}

/// @brief Stop the continuous data acquisition
void ADS1299::stopADS()
{
    STOP(BOTH_ADS); // stop the data acquisition
    delay(1);
    SDATAC(BOTH_ADS); // stop Read Data Continuous mode to communicate with ADS
    delay(1);
    isRunning = false;
}

/// @brief Call this to start the streaming data from the ADS1299
void ADS1299::streamStart()
{ // needs daisy functionality
    streaming = true;
    startADS();
}

/// @brief Start continuous data acquisition
void ADS1299::startADS()
{
    sampleCounter = 0;
    sampleCounterBLE = 0;
    firstDataPacket = true;
    RDATAC(BOTH_ADS); // enter Read Data Continuous mode
    delay(1);
    START(BOTH_ADS); // start the data acquisition
    delay(1);
    isRunning = true;
}